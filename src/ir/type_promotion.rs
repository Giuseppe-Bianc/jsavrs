//! # Type Promotion System for IR
//!
//! This module implements a comprehensive type promotion system for the jsavrs intermediate representation (IR).
//! The system addresses the issue where binary operations in the IR were incorrectly inheriting the type
//! of the left operand without proper type promotion logic.
//!
//! ## Key Components
//!
//! - `TypePromotion`: Represents a single type promotion operation with source, target, and cast information
//! - `PromotionMatrix`: Defines the complete type promotion lattice and rules
//! - `PromotionRule`: Defines specific promotion behavior between two types (direct, indirect, or forbidden)
//! - `TypeGroup`: Groups types by mathematical properties for promotion ordering
//! - `PromotionResult`: Contains the result of type promotion analysis
//! - `PromotionWarning`: Represents warnings generated during type promotion
//! - `OverflowBehavior`: Configuration for runtime behavior on numeric overflow
//! - `PrecisionLossEstimate`: Quantifies potential precision loss in type conversions
//!
//! ## Type Promotion Rules
//!
//! The system follows a well-defined type lattice hierarchy:
//!
//! 1. Float types take highest precedence (F64 > F32 > Integer types)
//! 2. For same-width signed/unsigned integers, promote to the next larger signed type
//! 3. Wider types take precedence within the same signedness category
//! 4. Special handling for precision loss and overflow scenarios
//!
//! ## Numeric Type Conversions (100 rules implemented)
//!
//! ### Integer Widening Conversions (24 rules)
//!
//! Widening conversions (smaller â†’ larger type) use `IntSignExtend` for signed types
//! and `IntZeroExtend` for unsigned types. These conversions are lossless and safe:
//! - **Signed widening**: Sign bit is extended to preserve negative values (I8â†’I16, I8â†’I32, I8â†’I64, etc.)
//! - **Unsigned widening**: High-order bits are zero-filled (U8â†’U16, U8â†’U32, U8â†’U64, etc.)
//!
//! Examples: `i8 â†’ i32` preserves `-128`, `u8 â†’ u32` preserves `255`
//!
//! ### Integer Narrowing Conversions (24 rules)
//!
//! Narrowing conversions (larger â†’ smaller type) use `IntTruncate` and may result in:
//! - **Precision loss**: High-order bits discarded, tracked via `PrecisionLossEstimate::ValueRange`
//! - **Overflow**: Value exceeds target range (e.g., 300 â†’ i8 causes overflow)
//!
//! Examples:
//! - `u64 â†’ u16` truncates upper 48 bits, generating `PrecisionLoss` warning
//! - `i64 â†’ i32` truncates upper 32 bits, may overflow if value outside [-2Â³Â¹, 2Â³Â¹-1]
//!
//! ### Cross-Signedness Conversions (8 same-width + 24 different-width = 32 rules)
//!
//! **Same-width conversions** (8 rules) use `Bitcast` to reinterpret bits without transformation:
//! - **Positive signed â†’ unsigned**: Direct mapping (123_i32 â†’ 123_u32)
//! - **Negative signed â†’ unsigned**: Two's complement reinterpretation (-1_i32 â†’ 4294967295_u32)
//! - **Large unsigned â†’ signed**: Wrap to negative (128_u8 â†’ -128_i8)
//!
//! Generates `SignednessChange` warning because comparisons behave differently.
//!
//! **Different-width conversions** (24 rules) use `Indirect` rules combining width change + signedness change:
//! - **Widening**: I8 â†’ U16 via I8â†’I16 (sign-extend) â†’ U16 (bitcast)
//! - **Narrowing**: I32 â†’ U8 via I32â†’I8 (truncate) â†’ U8 (bitcast)
//!
//! ### Integer-Float Conversions (32 rules)
//!
//! **Integer â†’ Float** (16 rules):
//! - Uses `IntToFloat` cast kind
//! - Lossless for integers within mantissa precision (F32: 24 bits, F64: 53 bits)
//! - Generates `PrecisionLoss` warning for values exceeding mantissa precision
//! - Examples: `i32 â†’ f32` may lose precision for large values (e.g., 16777217_i32)
//!
//! **Float â†’ Integer** (16 rules):
//! - Uses `FloatToInt` cast kind
//! - Truncates fractional part (3.7 â†’ 3, -2.9 â†’ -2)
//! - Generates `PrecisionLoss(FractionalPart)` warning
//! - May overflow if float value exceeds integer range
//! - Special values: NaN â†’ 0, Â±Infinity â†’ INT_MAX/INT_MIN (behavior configurable via `OverflowBehavior`)
//!
//! ### Float-Float Conversions (4 rules)
//!
//! - **F64 â†’ F32** (`FloatTruncate`): Reduces precision, generates `PrecisionLoss(SignificantDigits { lost_bits: 29 })` warning
//! - **F32 â†’ F64** (`FloatExtend`): Lossless widening, no warnings
//! - **F32 â†’ F32** / **F64 â†’ F64** (identity): No-op conversion
//!
//! ## Precision Loss and Overflow Warnings
//!
//! The system tracks potential data loss via `PrecisionLossEstimate`:
//! - `ValueRange { from_bits, to_bits }`: For integer narrowing (e.g., 64â†’32 bits)
//! - `SignificantDigits { lost_bits }`: For float narrowing (F64â†’F32 loses 29 mantissa bits)
//! - `FractionalPart`: For floatâ†’integer (decimal portion discarded)
//!
//! Warnings are generated by:
//! - `generate_precision_loss_warning()`: Analyzes `may_lose_precision` flag and estimates
//! - `generate_signedness_change_warning()`: Detects Bitcast operations changing signedness
//!
//! ## Boolean Conversions (22 rules implemented)
//!
//! Boolean types support bidirectional conversions with numeric and string types.
//! All boolean conversions use `Direct` rules with no precision loss or overflow risk.
//!
//! ### Boolean to Numeric (10 rules)
//!
//! Converts boolean values to numeric representation using `BoolToInt` and `BoolToFloat` cast kinds:
//! - **Bool â†’ Integers** (8 rules): `true` â†’ 1, `false` â†’ 0
//!   - Supported targets: I8, I16, I32, I64, U8, U16, U32, U64
//!   - Examples: `true â†’ i32` yields 1, `false â†’ u8` yields 0
//! - **Bool â†’ Floats** (2 rules): `true` â†’ 1.0, `false` â†’ 0.0
//!   - Supported targets: F32, F64
//!   - Exact representation (0.0 and 1.0 exactly representable in IEEE 754)
//!
//! No runtime support or validation required. Conversions are deterministic and lossless.
//!
//! ### Numeric to Boolean (10 rules)
//!
//! Converts numeric values to boolean using zero test semantics:
//! - **Integers â†’ Bool** (8 rules): `0` â†’ `false`, non-zero â†’ `true`
//!   - Uses `IntToBool` cast kind
//!   - All integer values map deterministically (e.g., -5 â†’ true, 0 â†’ false)
//! - **Floats â†’ Bool** (2 rules): `Â±0.0` â†’ `false`, other â†’ `true`
//!   - Uses `FloatToBool` cast kind
//!   - Special values: `NaN` â†’ `true`, `Â±Infinity` â†’ `true`
//!   - Example: `3.14 â†’ true`, `-0.0 â†’ false`, `f64::NAN â†’ true`
//!
//! No runtime support or validation required. Zero test is well-defined for all numeric types.
//!
//! ### Boolean to String (2 rules)
//!
//! String formatting conversions require runtime support for memory allocation:
//! - **Bool â†’ String**: `true` â†’ `"true"`, `false` â†’ `"false"`
//!   - Uses `BoolToString` cast kind
//!   - Requires `requires_runtime_support: true` for string allocation
//!   - Lossless conversion (exact string representation)
//! - **String â†’ Bool**: Parses `"true"` / `"false"` (case-sensitive)
//!   - Uses `StringToBool` cast kind
//!   - Requires `requires_runtime_support: true` for parsing
//!   - Requires `requires_validation: true` to reject invalid strings (e.g., "True", "1", "yes")
//!   - Invalid strings should generate `InvalidStringConversion` warning
//!
//! ## Character Conversions (6 rules implemented)
//!
//! Character types represent Unicode scalar values (U+0000 to U+10FFFF, excluding surrogates).
//! All character conversions use `Direct` rules with validation where necessary.
//!
//! ### Character to Integer (2 rules)
//!
//! Extracts the Unicode scalar value as an integer:
//! - **Char â†’ U32**: Direct extraction of Unicode code point
//!   - Uses `CharToInt` cast kind
//!   - Lossless conversion (e.g., 'A' â†’ 65, 'ðŸ¦€' â†’ 129408)
//!   - No validation required (all `char` values are valid Unicode scalars)
//! - **Char â†’ I32**: Same as Char â†’ U32 (Unicode values fit in i32 range 0..=0x10FFFF)
//!   - Uses `CharToInt` cast kind
//!   - No validation required (max Unicode U+10FFFF fits in i32)
//!
//! ### Integer to Character (2 rules with validation)
//!
//! Converts integer values to Unicode characters with validation:
//! - **U32 â†’ Char**: Validates Unicode scalar range
//!   - Uses `IntToChar` cast kind
//!   - Requires `requires_validation: true` to check:
//!     * Value â‰¤ 0x10FFFF (maximum Unicode code point)
//!     * Value âˆ‰ [0xD800, 0xDFFF] (surrogate range reserved for UTF-16)
//!   - Invalid values generate `InvalidUnicodeCodePoint` warning via `generate_unicode_validation_warning()`
//!   - Examples: 65 â†’ 'A', 0xD800 â†’ ERROR (surrogate), 0x110000 â†’ ERROR (out of range)
//! - **I32 â†’ Char**: Validates non-negative and Unicode range
//!   - Uses `IntToChar` cast kind
//!   - Requires `requires_validation: true` to check:
//!     * Value â‰¥ 0 (negative values invalid)
//!     * Value â‰¤ 0x10FFFF and âˆ‰ [0xD800, 0xDFFF] (same as U32 â†’ Char)
//!   - Invalid values generate `InvalidUnicodeCodePoint` warning
//!
//! ### Character to String (2 rules with runtime support)
//!
//! Converts between single-character representations:
//! - **Char â†’ String**: Converts character to single-character string
//!   - Uses `CharToString` cast kind
//!   - Requires `requires_runtime_support: true` for string allocation
//!   - Lossless conversion (e.g., 'A' â†’ "A", 'ðŸ¦€' â†’ "ðŸ¦€")
//! - **String â†’ Char**: Extracts character from single-character string
//!   - Uses `StringToChar` cast kind
//!   - Requires `requires_runtime_support: true` for parsing
//!   - Requires `requires_validation: true` to ensure string length == 1
//!   - Empty strings or multi-character strings generate `InvalidStringConversion` warning
//!
//! ## Warning Generation for Boolean/Character Conversions
//!
//! Three warning generation methods handle validation scenarios:
//! - `generate_unicode_validation_warning()`: Validates integer â†’ char conversions
//!   - Checks Unicode scalar range (0..=0x10FFFF excluding 0xD800..=0xDFFF)
//!   - Generates `InvalidUnicodeCodePoint` with descriptive reasons:
//!     * "surrogate code point (reserved for UTF-16)" for 0xD800..=0xDFFF
//!     * "value exceeds maximum Unicode code point U+10FFFF" for values > 0x10FFFF
//! - String â†’ Bool / String â†’ Char conversions should generate `InvalidStringConversion` at runtime
//! - Boolean conversions generate no warnings (all conversions well-defined)
//!
//! ## String Conversions (23 new rules + 2 from Bool/Char = 25 total)
//!
//! String conversions enable interoperability between all primitive types and string representations.
//! These conversions fall into three categories: formatting (primitiveâ†’String), parsing (Stringâ†’primitive),
//! and identity (Stringâ†’String).
//!
//! ### Primitive to String Formatting (12 rules - Always succeed)
//!
//! All primitive types can be formatted to strings with guaranteed success:
//! - **Integers â†’ String** (8 rules): Decimal string representation
//!   - Types: I8, I16, I32, I64, U8, U16, U32, U64 â†’ String
//!   - Uses `IntToString` cast kind
//!   - Requires `requires_runtime_support: true` (heap allocation + formatting logic)
//!   - Examples: 42i32 â†’ "42", -5i8 â†’ "-5", 255u8 â†’ "255"
//!   - **Always succeeds** - no validation needed (`requires_validation: false`)
//!
//! - **Floats â†’ String** (2 rules): Scientific/standard notation
//!   - Types: F32, F64 â†’ String
//!   - Uses `FloatToString` cast kind
//!   - Requires `requires_runtime_support: true` (heap allocation + formatting)
//!   - Examples: 3.14f32 â†’ "3.14", f64::NAN â†’ "NaN", f32::INFINITY â†’ "inf"
//!   - **Always succeeds** - handles special values (NaN, infinity, -0.0)
//!
//! - **Bool â†’ String** (1 rule): Canonical boolean representation
//!   - Uses `BoolToString` cast kind
//!   - Requires `requires_runtime_support: true` (heap allocation)
//!   - Converts: `true` â†’ "true", `false` â†’ "false"
//!   - **Always succeeds** - deterministic mapping
//!
//! - **Char â†’ String** (1 rule): Single-character string
//!   - Uses `CharToString` cast kind
//!   - Requires `requires_runtime_support: true` (heap allocation)
//!   - Examples: 'A' â†’ "A", 'ðŸ¦€' â†’ "ðŸ¦€" (UTF-8 encoding)
//!   - **Always succeeds** - valid chars produce valid UTF-8
//!
//! ### String to Primitive Parsing (12 rules - May fail)
//!
//! Parsing string representations to primitives requires validation:
//! - **String â†’ Integers** (8 rules): Parse decimal integers
//!   - Types: String â†’ I8, I16, I32, I64, U8, U16, U32, U64
//!   - Uses `StringToInt` cast kind
//!   - Requires `requires_runtime_support: true` (parsing logic)
//!   - Requires `requires_validation: true` (may fail on invalid input)
//!   - Valid examples: "42" â†’ 42i32, "-5" â†’ -5i8, "255" â†’ 255u8
//!   - Invalid examples generate `InvalidStringConversion` warning:
//!     * "abc" â†’ ERROR (non-numeric)
//!     * "999999999999" â†’ ERROR (overflow for target type)
//!     * "-42" â†’ ERROR when parsing to unsigned type
//!     * "  42  " â†’ ERROR (leading/trailing whitespace not allowed)
//!
//! - **String â†’ Floats** (2 rules): Parse floating-point values
//!   - Types: String â†’ F32, F64
//!   - Uses `StringToFloat` cast kind
//!   - Requires `requires_runtime_support: true` (parsing logic)
//!   - Requires `requires_validation: true` (may fail on invalid format)
//!   - Valid examples: "3.14" â†’ 3.14f32, "NaN" â†’ f64::NAN, "inf" â†’ f32::INFINITY
//!   - Invalid examples generate `InvalidStringConversion` warning:
//!     * "not a number" â†’ ERROR
//!     * "3.14.15" â†’ ERROR (multiple decimal points)
//!
//! - **String â†’ Bool** (1 rule): Parse boolean keywords
//!   - Uses `StringToBool` cast kind
//!   - Requires `requires_runtime_support: true` + `requires_validation: true`
//!   - Valid: "true" â†’ true, "false" â†’ false (case-sensitive)
//!   - Invalid examples generate `InvalidStringConversion` warning:
//!     * "True", "FALSE", "1", "yes" â†’ ERROR (only "true"/"false" accepted)
//!
//! - **String â†’ Char** (1 rule): Extract single character
//!   - Uses `StringToChar` cast kind
//!   - Requires `requires_runtime_support: true` + `requires_validation: true`
//!   - Valid: "A" â†’ 'A', "ðŸ¦€" â†’ 'ðŸ¦€'
//!   - Invalid examples generate `InvalidStringConversion` warning:
//!     * "" â†’ ERROR (empty string)
//!     * "ABC" â†’ ERROR (multiple characters)
//!
//! ### String to String Identity (1 rule)
//!
//! - **String â†’ String**: No-op conversion
//!   - Uses `Bitcast` cast kind (no actual operation performed)
//!   - No runtime support needed (`requires_runtime_support: false`)
//!   - No validation needed (`requires_validation: false`)
//!   - Useful for uniform handling of all type conversions in IR generation
//!
//! ### String Conversion Warning Generation
//!
//! String parsing failures generate `InvalidStringConversion` warnings with detailed context:
//! - **Compile-time validation**: If string value is const-evaluable, parsing is attempted at compile time
//!   - Generates warning with exact string value: `InvalidStringConversion { string_value: Some("abc"), ... }`
//!   - Reason describes specific parse failure (e.g., "Cannot parse 'abc' as i32")
//! - **Runtime validation**: If string value is dynamic (computed at runtime)
//!   - Generates warning without string value: `InvalidStringConversion { string_value: None, ... }`
//!   - Reason indicates runtime check needed: "String parsing may fail at runtime"
//! - **Parsing rules**:
//!   - Integer parsing: Rejects non-numeric, overflow, negative for unsigned, leading/trailing whitespace
//!   - Float parsing: Rejects invalid format, accepts "NaN", "inf", "-inf"
//!   - Bool parsing: Only accepts "true" or "false" (case-sensitive)
//!   - Char parsing: Only accepts single-character strings (UTF-8 encoded)
//!
//! ## Usage Example
//!
//! ```rust
//! use jsavrs::ir::type_promotion::PromotionResult;
//! use jsavrs::ir::TypePromotionEngine;
//! use jsavrs::ir::types::IrType;
//! use jsavrs::ir::instruction::IrBinaryOp;
//! use jsavrs::location::source_span::SourceSpan;
//!
//! let engine = TypePromotionEngine::new();
//! let result: PromotionResult = engine.analyze_binary_promotion(
//!     &IrType::I32,
//!     &IrType::F32,
//!     IrBinaryOp::Add,
//!     SourceSpan::default()
//! );
//! // Result will show that promotion to F32 is required with appropriate cast instructions
//! ```
//!
//! ## Design Goals
//!
//! - **Correctness**: Ensure mathematically sound type promotions
//! - **Consistency**: Same expression always produces same result type
//! - **Precision Preservation**: Maintain maximum possible precision
//! - **Standard Compliance**: Follow IEEE floating-point and integer behavior
//! - **Performance**: Efficient O(1) promotion lookups for common cases

use crate::ir::types::IrType;
use crate::location::source_span::SourceSpan;
use std::collections::HashMap;

/// Central entity managing type promotion logic and rules
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TypePromotion {
    /// The source type being promoted from
    pub from_type: IrType,
    /// The target type being promoted to  
    pub to_type: IrType,
    /// The kind of cast operation required for this promotion
    pub cast_kind: CastKind,
    /// Whether this promotion may result in precision loss
    pub may_lose_precision: bool,
    /// Whether this promotion may result in value overflow/underflow
    pub may_overflow: bool,
    /// Source location for error reporting
    pub source_span: SourceSpan,
}

/// Defines the complete type promotion lattice and rules
#[derive(Debug, Clone)]
pub struct PromotionMatrix {
    /// Matrix of promotion rules indexed by (from_type, to_type)
    promotion_rules: HashMap<(IrType, IrType), PromotionRule>,
    /// Type precedence ordering for automatic promotion
    #[allow(dead_code)]
    type_precedence: Vec<TypeGroup>,
    /// Configuration for runtime behavior on errors
    overflow_behavior: OverflowBehavior,
}

impl Default for PromotionMatrix {
    fn default() -> Self {
        Self::new()
    }
}

/// Defines specific promotion behavior between two types
#[derive(Debug, Clone, PartialEq)]
pub enum PromotionRule {
    /// Direct promotion without intermediate steps
    Direct {
        cast_kind: CastKind,
        may_lose_precision: bool,
        may_overflow: bool,
        requires_runtime_support: bool, // NEW: For string conversions
        requires_validation: bool,      // NEW: For u32â†’char, Stringâ†’primitive
        precision_loss_estimate: Option<PrecisionLossEstimate>,
    },
    /// Promotion through intermediate type
    Indirect {
        intermediate_type: IrType,
        first_cast: CastKind,
        second_cast: CastKind,
        requires_runtime_support: bool, // NEW
    },
    /// Promotion not allowed
    Forbidden { reason: String },
}

/// Groups types by mathematical properties for promotion ordering
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeGroup {
    SignedIntegers(Vec<IrType>),   // I8, I16, I32, I64
    UnsignedIntegers(Vec<IrType>), // U8, U16, U32, U64
    FloatingPoint(Vec<IrType>),    // F32, F64
    Boolean,
    Character,
}

/// Contains the result of type promotion analysis
#[derive(Debug, Clone, PartialEq)]
pub struct PromotionResult {
    /// The target type for the operation result
    pub result_type: IrType,
    /// Cast required for left operand (if any)
    pub left_cast: Option<TypePromotion>,
    /// Cast required for right operand (if any)  
    pub right_cast: Option<TypePromotion>,
    /// Warnings generated during promotion analysis
    pub warnings: Vec<PromotionWarning>,
    /// Whether the promotion is mathematically sound
    pub is_sound: bool,
}

/// Represents warnings generated during type promotion
#[derive(Debug, Clone, PartialEq)]
pub enum PromotionWarning {
    PrecisionLoss {
        from_type: IrType,
        to_type: IrType,
        estimated_loss: PrecisionLossEstimate,
    },
    PotentialOverflow {
        from_type: IrType,
        to_type: IrType,
        operation: IrBinaryOp,
    },
    SignednessChange {
        from_signed: bool,
        to_signed: bool,
        may_affect_comparisons: bool,
    },
    /// Float special values in type conversions (updated for type conversion context)
    FloatSpecialValues {
        value_type: FloatSpecialValueType,  // NaN | PosInf | NegInf
        source_type: IrType,                // F32 or F64
        target_type: IrType,                // I8-I64, U8-U64
        applied_behavior: OverflowBehavior, // Wrap | Saturate | Trap | CompileError
        source_span: SourceSpan,
    },
    /// Invalid string conversion (unparseable)
    InvalidStringConversion {
        string_value: Option<String>,
        target_type: IrType,
        reason: String,
    },
    /// Invalid Unicode code point for char
    InvalidUnicodeCodePoint {
        value: u32,
        reason: String,
    },
}

/// Helper enum for float special value types
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FloatSpecialValueType {
    NaN,
    PositiveInfinity,
    NegativeInfinity,
}

/// Configuration for runtime behavior on numeric overflow
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum OverflowBehavior {
    /// Wrap around using modulo arithmetic
    Wrap,
    /// Saturate to maximum/minimum values
    Saturate,
    /// Generate runtime trap/panic
    Trap,
    /// Compiler error for statically detectable overflow
    CompileError,
}

/// Quantifies potential precision loss in type conversions
#[derive(Debug, Clone, PartialEq)]
pub enum PrecisionLossEstimate {
    /// No precision loss expected
    None,
    /// Fractional part may be lost (float to int)
    FractionalPart,
    /// Significant digits may be lost (f64 to f32)
    SignificantDigits { lost_bits: u32 },
    /// Complete value range change (large int to small int)
    ValueRange { from_bits: u32, to_bits: u32 },
}

impl PromotionMatrix {
    pub fn new() -> Self {
        Self::with_overflow_behavior(OverflowBehavior::Saturate)
    }

    pub fn with_overflow_behavior(overflow_behavior: OverflowBehavior) -> Self {
        let mut matrix = PromotionMatrix {
            promotion_rules: HashMap::new(),
            type_precedence: vec![
                TypeGroup::FloatingPoint(vec![IrType::F32, IrType::F64]),
                TypeGroup::SignedIntegers(vec![IrType::I8, IrType::I16, IrType::I32, IrType::I64]),
                TypeGroup::UnsignedIntegers(vec![IrType::U8, IrType::U16, IrType::U32, IrType::U64]),
                TypeGroup::Boolean,
                TypeGroup::Character,
            ],
            overflow_behavior,
        };

        // Initialize the promotion matrix with default rules
        matrix.initialize_default_promotions();
        matrix
    }

    pub fn get_overflow_behavior(&self) -> OverflowBehavior {
        self.overflow_behavior
    }

    pub fn set_overflow_behavior(&mut self, behavior: OverflowBehavior) {
        self.overflow_behavior = behavior;
    }

    fn initialize_default_promotions(&mut self) {
        // Floating point promotions
        self.add_promotion_rule(
            IrType::F64,
            IrType::F32,
            PromotionRule::Direct {
                cast_kind: CastKind::FloatTruncate,
                may_lose_precision: true,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: Some(PrecisionLossEstimate::SignificantDigits { lost_bits: 29 }), // f64 mantissa 52, f32 mantissa 23
            },
        );
        self.add_promotion_rule(
            IrType::F32,
            IrType::F64,
            PromotionRule::Direct {
                cast_kind: CastKind::FloatExtend,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );

        // Add all signed integer widening promotions
        self.add_integer_widening_promotions(
            &[(IrType::I8, 8), (IrType::I16, 16), (IrType::I32, 32), (IrType::I64, 64)],
            CastKind::IntSignExtend,
        );

        // Add all unsigned integer widening promotions
        self.add_integer_widening_promotions(
            &[(IrType::U8, 8), (IrType::U16, 16), (IrType::U32, 32), (IrType::U64, 64)],
            CastKind::IntZeroExtend,
        );

        // Add float with integer promotions
        let signed_types = [(IrType::I8, 8), (IrType::I16, 16), (IrType::I32, 32), (IrType::I64, 64)];
        let unsigned_types = [(IrType::U8, 8), (IrType::U16, 16), (IrType::U32, 32), (IrType::U64, 64)];
        self.add_float_integer_promotions(&signed_types);
        self.add_float_integer_promotions(&unsigned_types);

        // Add integer narrowing promotions (T016)
        self.add_integer_narrowing_promotions();

        // Add cross-signedness promotion rules for same-width types
        self.add_cross_signedness_promotions();

        // Add cross-signedness conversions with different widths (24 rules via Indirect)
        self.add_cross_signedness_different_width_promotions();

        // Add boolean promotion rules (T025)
        self.add_boolean_promotions();

        // Add character promotion rules (T027)
        self.add_character_promotions();

        // Add string promotion rules (T035)
        self.add_string_promotions();

        // Add identity promotions for all basic types
        self.add_identity_promotions();
    }

    /// Helper function to add widening promotions for integer types
    fn add_integer_widening_promotions(&mut self, types: &[(IrType, u32)], cast_kind: CastKind) {
        for i in 0..types.len() {
            for j in (i + 1)..types.len() {
                let (from_type, _) = &types[i];
                let (to_type, _) = &types[j];
                self.add_promotion_rule(
                    from_type.clone(),
                    to_type.clone(),
                    PromotionRule::Direct {
                        cast_kind,
                        may_lose_precision: false,
                        may_overflow: false,
                        requires_runtime_support: false,
                        requires_validation: false,
                        precision_loss_estimate: None,
                    },
                );
            }
        }
    }

    /// Helper function to add float to integer and integer to float promotions
    fn add_float_integer_promotions(&mut self, int_types: &[(IrType, u32)]) {
        for (int_type, _) in int_types {
            // F32 to int type
            self.add_promotion_rule(
                IrType::F32,
                int_type.clone(),
                PromotionRule::Direct {
                    cast_kind: CastKind::FloatToInt,
                    may_lose_precision: true,
                    may_overflow: true,
                    requires_runtime_support: false,
                    requires_validation: false,
                    precision_loss_estimate: Some(PrecisionLossEstimate::FractionalPart),
                },
            );
            // Int type to F32
            self.add_promotion_rule(
                int_type.clone(),
                IrType::F32,
                PromotionRule::Direct {
                    cast_kind: CastKind::IntToFloat,
                    may_lose_precision: false,
                    may_overflow: false,
                    requires_runtime_support: false,
                    requires_validation: false,
                    precision_loss_estimate: None,
                },
            );
            // F64 to int type
            self.add_promotion_rule(
                IrType::F64,
                int_type.clone(),
                PromotionRule::Direct {
                    cast_kind: CastKind::FloatToInt,
                    may_lose_precision: true,
                    may_overflow: true,
                    requires_runtime_support: false,
                    requires_validation: false,
                    precision_loss_estimate: Some(PrecisionLossEstimate::FractionalPart),
                },
            );
            // Int type to F64
            self.add_promotion_rule(
                int_type.clone(),
                IrType::F64,
                PromotionRule::Direct {
                    cast_kind: CastKind::IntToFloat,
                    may_lose_precision: false,
                    may_overflow: false,
                    requires_runtime_support: false,
                    requires_validation: false,
                    precision_loss_estimate: None,
                },
            );
        }
    }

    /// Add cross-signedness promotion rules for same-width types
    fn add_cross_signedness_promotions(&mut self) {
        // These should promote to a common type according to C++ promotion rules
        self.add_promotion_rule(
            IrType::I8,
            IrType::U8,
            PromotionRule::Direct {
                cast_kind: CastKind::Bitcast,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );
        self.add_promotion_rule(
            IrType::I16,
            IrType::U16,
            PromotionRule::Direct {
                cast_kind: CastKind::Bitcast,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );
        self.add_promotion_rule(
            IrType::I32,
            IrType::U32,
            PromotionRule::Direct {
                cast_kind: CastKind::Bitcast,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );
        self.add_promotion_rule(
            IrType::I64,
            IrType::U64,
            PromotionRule::Direct {
                cast_kind: CastKind::Bitcast,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );
    }

    /// Add cross-signedness conversions with different widths (24 rules via Indirect)
    fn add_cross_signedness_different_width_promotions(&mut self) {
        let signed_types = vec![IrType::I8, IrType::I16, IrType::I32, IrType::I64];
        let unsigned_types = vec![IrType::U8, IrType::U16, IrType::U32, IrType::U64];

        for (i, from_signed) in signed_types.iter().enumerate() {
            for (j, to_unsigned) in unsigned_types.iter().enumerate() {
                if i == j {
                    continue; // Skip same-width (handled by add_cross_signedness_promotions)
                }

                if i < j {
                    // Widening: signed â†’ unsigned (larger)
                    // E.g., I8 â†’ U16: I8 â†’ I16 (sign-extend) â†’ U16 (bitcast)
                    let intermediate = signed_types[j].clone();
                    self.add_promotion_rule(
                        from_signed.clone(),
                        to_unsigned.clone(),
                        PromotionRule::Indirect {
                            intermediate_type: intermediate,
                            first_cast: CastKind::IntSignExtend,
                            second_cast: CastKind::Bitcast,
                            requires_runtime_support: false,
                        },
                    );
                } else {
                    // Narrowing: signed â†’ unsigned (smaller)
                    // E.g., I32 â†’ U8: I32 â†’ I8 (truncate) â†’ U8 (bitcast)
                    let intermediate = signed_types[j].clone();
                    self.add_promotion_rule(
                        from_signed.clone(),
                        to_unsigned.clone(),
                        PromotionRule::Indirect {
                            intermediate_type: intermediate,
                            first_cast: CastKind::IntTruncate,
                            second_cast: CastKind::Bitcast,
                            requires_runtime_support: false,
                        },
                    );
                }
            }
        }

        for (i, from_unsigned) in unsigned_types.iter().enumerate() {
            for (j, to_signed) in signed_types.iter().enumerate() {
                if i == j {
                    continue; // Skip same-width
                }

                if i < j {
                    // Widening: unsigned â†’ signed (larger)
                    // E.g., U8 â†’ I16: U8 â†’ U16 (identity) â†’ I16 (bitcast)
                    let intermediate = unsigned_types[j].clone();
                    self.add_promotion_rule(
                        from_unsigned.clone(),
                        to_signed.clone(),
                        PromotionRule::Indirect {
                            intermediate_type: intermediate,
                            first_cast: CastKind::IntZeroExtend,
                            second_cast: CastKind::Bitcast,
                            requires_runtime_support: false,
                        },
                    );
                } else {
                    // Narrowing: unsigned â†’ signed (smaller)
                    // E.g., U32 â†’ I8: U32 â†’ U8 (truncate) â†’ I8 (bitcast)
                    let intermediate = unsigned_types[j].clone();
                    self.add_promotion_rule(
                        from_unsigned.clone(),
                        to_signed.clone(),
                        PromotionRule::Indirect {
                            intermediate_type: intermediate,
                            first_cast: CastKind::IntTruncate,
                            second_cast: CastKind::Bitcast,
                            requires_runtime_support: false,
                        },
                    );
                }
            }
        }
    }

    /// Add identity promotions for all basic types
    fn add_identity_promotions(&mut self) {
        let all_types = vec![
            IrType::I8,
            IrType::I16,
            IrType::I32,
            IrType::I64,
            IrType::U8,
            IrType::U16,
            IrType::U32,
            IrType::U64,
            IrType::F32,
            IrType::F64,
            IrType::Bool,
            IrType::Char,
        ];

        for ty in all_types {
            self.add_symmetric_promotion_rule(ty.clone(), ty);
        }
    }

    fn add_symmetric_promotion_rule(&mut self, from: IrType, to: IrType) {
        self.promotion_rules.insert(
            (from, to),
            PromotionRule::Direct {
                cast_kind: CastKind::Bitcast, // No cast needed for same type
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );
    }

    fn add_promotion_rule(&mut self, from: IrType, to: IrType, rule: PromotionRule) {
        self.promotion_rules.insert((from.clone(), to.clone()), rule.clone());
        // Add symmetric rule if needed (same types)
        if from == to {
            self.add_symmetric_promotion_rule(from, to);
        } else {
            // Also add the inverse if it's not already defined
            if !self.promotion_rules.contains_key(&(to.clone(), from.clone())) {
                // For now, just add the same rule in reverse, though in a real implementation
                // we might want to define specific reverse rules
                if let PromotionRule::Direct {
                    cast_kind,
                    may_lose_precision,
                    may_overflow,
                    requires_runtime_support,
                    requires_validation,
                    precision_loss_estimate,
                } = &rule
                {
                    self.promotion_rules.insert(
                        (to, from),
                        PromotionRule::Direct {
                            cast_kind: *cast_kind,
                            may_lose_precision: *may_lose_precision,
                            may_overflow: *may_overflow,
                            requires_runtime_support: *requires_runtime_support,
                            requires_validation: *requires_validation,
                            precision_loss_estimate: precision_loss_estimate.clone(),
                        },
                    );
                }
            }
        }
    }

    pub fn get_promotion_rule(&self, from: &IrType, to: &IrType) -> Option<&PromotionRule> {
        self.promotion_rules.get(&(from.clone(), to.clone()))
    }

    pub fn compute_common_type(&self, left: &IrType, right: &IrType) -> Option<IrType> {
        if left == right {
            return Some(left.clone());
        }

        // Check if there's a direct promotion rule
        if self.get_promotion_rule(left, right).is_some() {
            // Use the higher precedence type based on the type lattice
            return Some(self.get_higher_type(left, right));
        }

        // Default fallback: look for common promotion type
        match (left, right) {
            // Float takes precedence over integers
            (IrType::F64, _) | (_, IrType::F64) => Some(IrType::F64),
            (IrType::F32, _) | (_, IrType::F32) => Some(IrType::F32),

            // Signed/unsigned of same width promote to next size up (or larger signed for I64/U64)
            (IrType::I64, IrType::U64) | (IrType::U64, IrType::I64) => Some(IrType::I64), // ADD THIS
            (IrType::I32, IrType::U32) | (IrType::U32, IrType::I32) => Some(IrType::I64),
            (IrType::I16, IrType::U16) | (IrType::U16, IrType::I16) => Some(IrType::I32),
            (IrType::I8, IrType::U8) | (IrType::U8, IrType::I8) => Some(IrType::I16),

            // Wider types take precedence within same signedness
            (IrType::I64, _) | (_, IrType::I64) => Some(IrType::I64),
            (IrType::U64, _) | (_, IrType::U64) => Some(IrType::U64),
            (IrType::I32, _) | (_, IrType::I32) => Some(IrType::I32),
            (IrType::U32, _) | (_, IrType::U32) => Some(IrType::U32),
            (IrType::I16, _) | (_, IrType::I16) => Some(IrType::I16),
            (IrType::U16, _) | (_, IrType::U16) => Some(IrType::U16),
            (IrType::I8, _) | (_, IrType::I8) => Some(IrType::I8),
            (IrType::U8, _) | (_, IrType::U8) => Some(IrType::U8),

            // Handle other type combinations as needed
            _ => Some(IrType::I32), // fallback
        }
    }

    fn get_higher_type(&self, left: &IrType, right: &IrType) -> IrType {
        // Use the type lattice to determine higher precedence
        // Delegating to a shared helper function to avoid duplication
        Self::determine_type_precedence(left, right)
    }

    /// Helper function to determine type precedence based on the type lattice
    fn determine_type_precedence(left: &IrType, right: &IrType) -> IrType {
        match (left, right) {
            // Float types take highest precedence
            (IrType::F64, _) | (_, IrType::F64) => IrType::F64,
            (IrType::F32, _) | (_, IrType::F32) => IrType::F32,

            // For same width signed/unsigned, promote to next size (as per spec)
            (IrType::I64, IrType::U64) | (IrType::U64, IrType::I64) => IrType::I64,
            (IrType::I32, IrType::U32) | (IrType::U32, IrType::I32) => IrType::I64,
            (IrType::I16, IrType::U16) | (IrType::U16, IrType::I16) => IrType::I32,
            (IrType::I8, IrType::U8) | (IrType::U8, IrType::I8) => IrType::I16,

            // Within same type group, prefer wider type
            (IrType::I64, _) | (_, IrType::I64) => IrType::I64,
            (IrType::U64, _) | (_, IrType::U64) => IrType::U64,
            (IrType::I32, _) | (_, IrType::I32) => IrType::I32,
            (IrType::U32, _) | (_, IrType::U32) => IrType::U32,
            (IrType::I16, _) | (_, IrType::I16) => IrType::I16,
            (IrType::U16, _) | (_, IrType::U16) => IrType::U16,

            _ => left.clone(), // fallback to left type
        }
    }

    /// Add all integer narrowing conversion rules (24 rules)
    /// Narrowing: Larger â†’ Smaller within same signedness
    fn add_integer_narrowing_promotions(&mut self) {
        // Signed narrowing (6 rules: I64â†’I32, I64â†’I16, I64â†’I8, I32â†’I16, I32â†’I8, I16â†’I8)
        let signed_types = [(IrType::I8, 8), (IrType::I16, 16), (IrType::I32, 32), (IrType::I64, 64)];
        for i in 0..signed_types.len() {
            for j in 0..i {
                let (from_type, from_bits) = &signed_types[i];
                let (to_type, to_bits) = &signed_types[j];
                self.add_promotion_rule(
                    from_type.clone(),
                    to_type.clone(),
                    PromotionRule::Direct {
                        cast_kind: CastKind::IntTruncate,
                        may_lose_precision: true,
                        may_overflow: true,
                        requires_runtime_support: false,
                        requires_validation: false,
                        precision_loss_estimate: Some(PrecisionLossEstimate::ValueRange {
                            from_bits: *from_bits,
                            to_bits: *to_bits,
                        }),
                    },
                );
            }
        }

        // Unsigned narrowing (6 rules: U64â†’U32, U64â†’U16, U64â†’U8, U32â†’U16, U32â†’U8, U16â†’U8)
        let unsigned_types = [(IrType::U8, 8), (IrType::U16, 16), (IrType::U32, 32), (IrType::U64, 64)];
        for i in 0..unsigned_types.len() {
            for j in 0..i {
                let (from_type, from_bits) = &unsigned_types[i];
                let (to_type, to_bits) = &unsigned_types[j];
                self.add_promotion_rule(
                    from_type.clone(),
                    to_type.clone(),
                    PromotionRule::Direct {
                        cast_kind: CastKind::IntTruncate,
                        may_lose_precision: true,
                        may_overflow: true,
                        requires_runtime_support: false,
                        requires_validation: false,
                        precision_loss_estimate: Some(PrecisionLossEstimate::ValueRange {
                            from_bits: *from_bits,
                            to_bits: *to_bits,
                        }),
                    },
                );
            }
        }
    }

    /// Add all boolean conversion rules (24 rules total)
    /// - Bool â†’ Integers (8 rules): Bool to I8, I16, I32, I64, U8, U16, U32, U64
    /// - Integers â†’ Bool (8 rules): zero test (0 â†’ false, non-zero â†’ true)
    /// - Bool â†” Floats (4 rules): Bool â†” F32, Bool â†” F64
    /// - Bool â†” String (2 rules): "true"/"false" conversions (requires runtime support)
    /// - Bool â†” Char (2 rules): Not implemented yet (future enhancement)
    fn add_boolean_promotions(&mut self) {
        // Bool â†’ Integers (8 rules)
        let int_types =
            vec![IrType::I8, IrType::I16, IrType::I32, IrType::I64, IrType::U8, IrType::U16, IrType::U32, IrType::U64];

        for int_ty in &int_types {
            self.add_promotion_rule(
                IrType::Bool,
                int_ty.clone(),
                PromotionRule::Direct {
                    cast_kind: CastKind::BoolToInt,
                    may_lose_precision: false, // 0 or 1 always fits
                    may_overflow: false,
                    requires_runtime_support: false,
                    requires_validation: false,
                    precision_loss_estimate: None,
                },
            );
        }

        // Integers â†’ Bool (8 rules)
        for int_ty in &int_types {
            self.add_promotion_rule(
                int_ty.clone(),
                IrType::Bool,
                PromotionRule::Direct {
                    cast_kind: CastKind::IntToBool,
                    may_lose_precision: false, // Zero test is well-defined
                    may_overflow: false,
                    requires_runtime_support: false,
                    requires_validation: false,
                    precision_loss_estimate: None,
                },
            );
        }

        // Bool â†’ Floats (2 rules)
        self.add_promotion_rule(
            IrType::Bool,
            IrType::F32,
            PromotionRule::Direct {
                cast_kind: CastKind::BoolToFloat,
                may_lose_precision: false, // 0.0 or 1.0 exactly representable
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );

        self.add_promotion_rule(
            IrType::Bool,
            IrType::F64,
            PromotionRule::Direct {
                cast_kind: CastKind::BoolToFloat,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );

        // Floats â†’ Bool (2 rules)
        self.add_promotion_rule(
            IrType::F32,
            IrType::Bool,
            PromotionRule::Direct {
                cast_kind: CastKind::FloatToBool,
                may_lose_precision: false, // Zero test is well-defined (Â±0.0 â†’ false, other â†’ true, NaN â†’ true)
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );

        self.add_promotion_rule(
            IrType::F64,
            IrType::Bool,
            PromotionRule::Direct {
                cast_kind: CastKind::FloatToBool,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );

        // Bool â†” String (2 rules) - requires runtime support for string operations
        self.add_promotion_rule(
            IrType::Bool,
            IrType::String,
            PromotionRule::Direct {
                cast_kind: CastKind::BoolToString,
                may_lose_precision: false, // Lossless: true â†’ "true", false â†’ "false"
                may_overflow: false,
                requires_runtime_support: true, // String allocation required
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );

        self.add_promotion_rule(
            IrType::String,
            IrType::Bool,
            PromotionRule::Direct {
                cast_kind: CastKind::StringToBool,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: true, // String parsing required
                requires_validation: true,      // "true"/"false" validation needed
                precision_loss_estimate: None,
            },
        );
    }

    /// Add all character conversion rules (6 rules)
    ///
    /// Character conversions support:
    /// - Char â†” U32: Direct conversion (Unicode scalar values)
    /// - Char â†” I32: Direct conversion with validation for negative values
    /// - Char â†” String: Runtime support for character-string conversions
    ///
    /// All conversions require Unicode validation where applicable:
    /// - U32 â†’ Char: Must be valid Unicode scalar (exclude surrogates D800-DFFF)
    /// - I32 â†’ Char: Must be non-negative and valid scalar
    /// - String â†’ Char: Must be exactly one character
    fn add_character_promotions(&mut self) {
        // Char â†’ U32: Direct Unicode scalar value extraction
        self.add_promotion_rule(
            IrType::Char,
            IrType::U32,
            PromotionRule::Direct {
                cast_kind: CastKind::CharToInt,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );

        // U32 â†’ Char: Requires Unicode scalar validation
        self.add_promotion_rule(
            IrType::U32,
            IrType::Char,
            PromotionRule::Direct {
                cast_kind: CastKind::IntToChar,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: true, // Validate Unicode scalar (exclude D800-DFFF)
                precision_loss_estimate: None,
            },
        );

        // Char â†’ I32: Direct conversion (Unicode values fit in i32)
        self.add_promotion_rule(
            IrType::Char,
            IrType::I32,
            PromotionRule::Direct {
                cast_kind: CastKind::CharToInt,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );

        // I32 â†’ Char: Requires validation for negative values
        self.add_promotion_rule(
            IrType::I32,
            IrType::Char,
            PromotionRule::Direct {
                cast_kind: CastKind::IntToChar,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false,
                requires_validation: true, // Validate non-negative and Unicode scalar
                precision_loss_estimate: None,
            },
        );

        // Char â†’ String: Runtime support for character to string conversion
        self.add_promotion_rule(
            IrType::Char,
            IrType::String,
            PromotionRule::Direct {
                cast_kind: CastKind::CharToString,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: true,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );

        // String â†’ Char: Runtime support with length validation
        self.add_promotion_rule(
            IrType::String,
            IrType::Char,
            PromotionRule::Direct {
                cast_kind: CastKind::StringToChar,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: true,
                requires_validation: true, // Validate exactly one character
                precision_loss_estimate: None,
            },
        );
    }

    /// Add all string conversion rules (25 rules)
    ///
    /// String conversions fall into three categories:
    /// 1. Primitive â†’ String (12 rules): Always succeed, require runtime formatting
    /// 2. String â†’ Primitive (12 rules): May fail, require runtime parsing + validation
    /// 3. String â†’ String (1 rule): Identity/no-op
    fn add_string_promotions(&mut self) {
        // =====================================================================
        // Integers â†’ String (8 rules) - Formatting always succeeds
        // =====================================================================
        let int_types =
            [IrType::I8, IrType::I16, IrType::I32, IrType::I64, IrType::U8, IrType::U16, IrType::U32, IrType::U64];

        for int_ty in &int_types {
            self.add_promotion_rule(
                int_ty.clone(),
                IrType::String,
                PromotionRule::Direct {
                    cast_kind: CastKind::IntToString,
                    may_lose_precision: false, // Formatting is lossless
                    may_overflow: false,
                    requires_runtime_support: true, // Heap allocation + formatting
                    requires_validation: false,     // Always succeeds
                    precision_loss_estimate: None,
                },
            );
        }

        // =====================================================================
        // String â†’ Integers (8 rules) - Parsing may fail
        // =====================================================================
        for int_ty in &int_types {
            self.add_promotion_rule(
                IrType::String,
                int_ty.clone(),
                PromotionRule::Direct {
                    cast_kind: CastKind::StringToInt,
                    may_lose_precision: false,      // Parsing is exact
                    may_overflow: false,            // But may fail validation
                    requires_runtime_support: true, // Parsing logic
                    requires_validation: true,      // Invalid format, overflow, etc.
                    precision_loss_estimate: None,
                },
            );
        }

        // =====================================================================
        // Floats â†’ String (2 rules) - Formatting always succeeds
        // =====================================================================
        self.add_promotion_rule(
            IrType::F32,
            IrType::String,
            PromotionRule::Direct {
                cast_kind: CastKind::FloatToString,
                may_lose_precision: false, // Formatting preserves value
                may_overflow: false,
                requires_runtime_support: true, // Heap allocation + formatting
                requires_validation: false,     // Always succeeds
                precision_loss_estimate: None,
            },
        );

        self.add_promotion_rule(
            IrType::F64,
            IrType::String,
            PromotionRule::Direct {
                cast_kind: CastKind::FloatToString,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: true,
                requires_validation: false,
                precision_loss_estimate: None,
            },
        );

        // =====================================================================
        // String â†’ Floats (2 rules) - Parsing may fail
        // =====================================================================
        self.add_promotion_rule(
            IrType::String,
            IrType::F32,
            PromotionRule::Direct {
                cast_kind: CastKind::StringToFloat,
                may_lose_precision: false,      // Parsing is exact
                may_overflow: false,            // But may fail validation
                requires_runtime_support: true, // Parsing logic
                requires_validation: true,      // Invalid format, NaN, inf, etc.
                precision_loss_estimate: None,
            },
        );

        self.add_promotion_rule(
            IrType::String,
            IrType::F64,
            PromotionRule::Direct {
                cast_kind: CastKind::StringToFloat,
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: true,
                requires_validation: true,
                precision_loss_estimate: None,
            },
        );

        // =====================================================================
        // String â†’ String (1 rule) - Identity/no-op
        // =====================================================================
        self.add_promotion_rule(
            IrType::String,
            IrType::String,
            PromotionRule::Direct {
                cast_kind: CastKind::Bitcast, // No-op, no actual cast needed
                may_lose_precision: false,
                may_overflow: false,
                requires_runtime_support: false, // Identity operation
                requires_validation: false,      // No validation needed
                precision_loss_estimate: None,
            },
        );

        // Note: Boolâ†”String and Charâ†”String rules already added in T025 and T027
    }

    /// Generate precision loss warning for a type conversion (T019)
    /// This method analyzes a promotion rule and generates appropriate PrecisionLoss warnings
    pub fn generate_precision_loss_warning(
        &self, from_type: &IrType, to_type: &IrType, rule: &PromotionRule,
    ) -> Option<PromotionWarning> {
        if let PromotionRule::Direct { may_lose_precision, precision_loss_estimate, .. } = rule {
            if *may_lose_precision {
                if let Some(estimate) = precision_loss_estimate {
                    return Some(PromotionWarning::PrecisionLoss {
                        from_type: from_type.clone(),
                        to_type: to_type.clone(),
                        estimated_loss: estimate.clone(),
                    });
                }
            }
        }
        None
    }

    /// Generate signedness change warning for a type conversion (T020)
    /// This method detects same-width signedâ†”unsigned conversions using Bitcast
    pub fn generate_signedness_change_warning(
        &self, from_type: &IrType, to_type: &IrType, rule: &PromotionRule,
    ) -> Option<PromotionWarning> {
        if let PromotionRule::Direct { cast_kind, .. } = rule {
            if *cast_kind == CastKind::Bitcast {
                let from_signed = from_type.is_signed_integer();
                let to_signed = to_type.is_signed_integer();
                // Check if exactly one is signed (XOR logic)
                if from_signed != to_signed {
                    return Some(PromotionWarning::SignednessChange {
                        from_signed,
                        to_signed,
                        may_affect_comparisons: true,
                    });
                }
            }
        }
        None
    }

    /// Generate Unicode validation warning for integerâ†’char conversions (T030)
    /// This method validates Unicode scalar values for u32â†’char and i32â†’char conversions
    /// Validates that the value is a valid Unicode scalar (U+0000 to U+10FFFF, excluding surrogates U+D800-U+DFFF)
    pub fn generate_unicode_validation_warning(&self, value: u32, to_type: &IrType) -> Option<PromotionWarning> {
        // Only generate warnings for char target type
        if *to_type != IrType::Char {
            return None;
        }

        // Validate Unicode scalar value
        if !Self::is_valid_unicode_scalar(value) {
            let reason = if (0xD800..=0xDFFF).contains(&value) {
                "surrogate code point (reserved for UTF-16)".to_string()
            } else if value > 0x10FFFF {
                "value exceeds maximum Unicode code point U+10FFFF".to_string()
            } else {
                "invalid Unicode scalar value".to_string()
            };

            return Some(PromotionWarning::InvalidUnicodeCodePoint { value, reason });
        }

        None
    }

    /// Check if a u32 value is a valid Unicode scalar value
    /// Valid range: U+0000 to U+10FFFF, excluding surrogate pairs U+D800 to U+DFFF
    fn is_valid_unicode_scalar(value: u32) -> bool {
        value <= 0x10FFFF && !(0xD800..=0xDFFF).contains(&value)
    }
}

impl TypePromotion {
    pub fn new(from_type: IrType, to_type: IrType, cast_kind: CastKind, source_span: SourceSpan) -> Self {
        TypePromotion {
            from_type,
            to_type,
            cast_kind,
            may_lose_precision: false, // Will be set based on promotion rule
            may_overflow: false,       // Will be set based on promotion rule
            source_span,
        }
    }
}

/// Handles type promotion for binary operations specifically
#[derive(Debug, Clone, PartialEq)]
pub struct BinaryOperationPromotion {
    /// Left operand value and type
    pub left_operand: Value,
    /// Right operand value and type
    pub right_operand: Value,
    /// The binary operation being performed
    pub operation: IrBinaryOp,
    /// Result of promotion analysis
    pub promotion_result: PromotionResult,
    /// Source location for error reporting
    pub source_span: SourceSpan,
}

// Define the required enums that might not exist yet
use crate::ir::instruction::CastKind;
use crate::ir::instruction::IrBinaryOp;
use crate::ir::value::Value;
