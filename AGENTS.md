# Agent-Based Code Generation for `jsavrs`

This document outlines a conceptual framework for using AI agents to automate code generation and maintenance tasks within the `jsavrs` compiler project. By defining specialized agent roles and their interactions, we can create a powerful system for accelerating development and improving code quality.

## Agent Roles

We can define a set of agent roles, each with a specific responsibility in the code generation process:

### 1. Planner Agent

*   **Responsibility:** The Planner Agent is the orchestrator of the code generation process. It takes a high-level task as input (e.g., "add a new syntactic feature" or "optimize the IR generation") and breaks it down into a series of smaller, manageable steps.
*   **Input:** A natural language description of the desired feature or improvement.
*   **Output:** A detailed plan of action, including the files to be modified, the new functions to be created, and the tests to be written.
*   **Tooling:** The Planner Agent would use its understanding of the `jsavrs` codebase, as documented in `GEMINI.md`, to create a realistic and effective plan.

### 2. Coder Agent

*   **Responsibility:** The Coder Agent is responsible for writing the actual code. It takes a specific coding task from the Planner Agent and generates the corresponding Rust code.
*   **Input:** A detailed description of a function or module to be implemented, including its signature, logic, and any relevant data structures.
*   **Output:** Rust code that implements the specified functionality, following the project's coding conventions.
*   **Tooling:** The Coder Agent would be an expert in Rust and would leverage the existing `jsavrs` codebase to ensure that the new code integrates seamlessly.

### 3. Tester Agent

*   **Responsibility:** The Tester Agent is responsible for ensuring the quality of the generated code. It takes the code generated by the Coder Agent and writes and runs tests to verify its correctness. Additionally, it performs duplicate code detection to maintain code quality.
*   **Input:** A piece of Rust code and a description of its expected behavior.
*   **Output:** A set of unit tests and integration tests that cover the new code, and the results of running those tests. Also, a report on code duplication if any is found.
*   **Tooling:** The Tester Agent would use the `cargo test` command and the `insta` snapshot testing framework to create and run tests. For duplicate code detection, it uses `similarity-rs`. If `similarity-rs` is not installed on the system, the Tester Agent will install it using `cargo install similarity-rs`. To verify the installation, it runs `similarity-rs --help`.
### 4. Refactor Agent

*   **Responsibility:** The Refactor Agent is responsible for improving the existing codebase. It can be tasked with refactoring a specific module to improve its readability, performance, or maintainability.
*   **Input:** A piece of Rust code and a set of refactoring goals (e.g., "reduce complexity" or "improve performance").
*   **Output:** A refactored version of the code that meets the specified goals.
*   **Tooling:** The Refactor Agent would use its understanding of Rust best practices and the `jsavrs` architecture to make intelligent refactoring decisions.
*   **Refactoring Output Requirement:** When performing refactoring operations, the Refactor Agent **must** display all modified code in a unified diff format (`diff -u` style) that clearly shows:
    *   File paths and line numbers for all changes
    *   Removed lines (prefixed with `-`)
    *   Added lines (prefixed with `+`)
    *   Context lines (unchanged code surrounding modifications)
    This comprehensive diff output ensures complete transparency of all changes made during refactoring, allowing reviewers to understand the full scope of modifications.
## Agent Interaction

The agents would interact in a sequential workflow:

1.  The **Planner Agent** receives a high-level task and creates a plan.
2.  The plan is broken down into a series of coding and testing tasks, which are assigned to the **Coder Agent** and **Tester Agent**, respectively.
3.  The **Coder Agent** generates the code for a specific task.
4.  The **Tester Agent** takes the generated code, writes tests for it, runs the tests, and performs duplicate code detection using `similarity-rs`.
5.  If the tests pass and no significant code duplication is found, the code is considered complete. If they fail or duplication is detected, the code is sent back to the **Coder Agent** for revision.
6.  The **Refactor Agent** can be invoked at any time to improve the quality of the existing code.

## Tool Integration

The agents would be tightly integrated with the existing tools and workflows of the `jsavrs` project:

*   **Version Control:** All code generated by the agents would be committed to a Git repository, allowing for version history and collaboration.
*   **Build System:** The agents would use `cargo` to build, run, and test the code.
*   **Testing Framework:** The agents would use `insta` to create and manage snapshot tests.
*   **Duplicate Code Detection:** The Tester Agent uses `similarity-rs` for detecting code duplication. If not present, it's installed via `cargo install similarity-rs` and verified with `similarity-rs --help`.
*   **CI/CD:** The agent-based system could be integrated into a CI/CD pipeline to automate the process of testing and deploying new code.

By leveraging the power of AI agents, we can significantly enhance the development process for `jsavrs`, making it faster, more efficient, and more reliable.


