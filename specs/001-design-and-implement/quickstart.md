# Quickstart Guide: x86-64 Assembly Code Generator

**Feature**: x86-64 Assembly Code Generator for jsavrs Compiler  
**Date**: 2025-09-28  
**Status**: Phase 1 Design Complete  
**Prerequisites**: jsavrs compiler with IR generation capability

## Overview

This quickstart guide demonstrates how to use the x86-64 assembly code generator to translate jsavrs intermediate representation (IR) into NASM-compatible assembly code. Follow these steps to generate, validate, and verify assembly output for your jsavrs programs.

## Quick Start (5 minutes)

### Step 1: Basic Assembly Generation

```bash
# Navigate to jsavrs project
cd /path/to/jsavrs

# Compile a simple program to IR and then to assembly
cargo run -- --input examples/hello_world.jsav --emit-ir --emit-asm --target x86_64-linux-gnu

# This generates:
# - hello_world.ir   (intermediate representation)
# - hello_world.asm  (NASM assembly)
```

### Step 2: Verify Assembly Output

```bash
# Assemble the generated code with NASM
nasm -f elf64 hello_world.asm -o hello_world.o

# Link the object file
ld hello_world.o -o hello_world

# Run the executable
./hello_world
```

### Step 3: Cross-Platform Generation

```bash
# Generate assembly for different platforms
cargo run -- --input examples/simple_function.jsav --emit-asm --target x86_64-windows-msvc
cargo run -- --input examples/simple_function.jsav --emit-asm --target x86_64-apple-darwin
cargo run -- --input examples/simple_function.jsav --emit-asm --target x86_64-unknown-linux-gnu
```

## Detailed Walkthrough (15 minutes)

### Example 1: Simple Function Translation

**Input** (`simple_add.jsav`):
```jsav
fn add_numbers(a: i32, b: i32) -> i32 {
    return a + b;
}

fn main() -> i32 {
    let result = add_numbers(5, 10);
    return result;
}
```

**Step 1: Generate IR and Assembly**
```bash
cargo run -- --input simple_add.jsav --emit-ir --emit-asm --target x86_64-linux-gnu --verbose
```

**Expected IR Output** (`simple_add.ir`):
```llvm
; IR representation (simplified)
define i32 @add_numbers(i32 %a, i32 %b) {
entry:
  %result = add i32 %a, %b
  ret i32 %result
}

define i32 @main() {
entry:
  %call_result = call i32 @add_numbers(i32 5, i32 10)
  ret i32 %call_result
}
```

**Expected Assembly Output** (`simple_add.asm`):
```nasm
; Generated by jsavrs x86-64 assembly generator
section .text
    global main
    global add_numbers

add_numbers:
    ; Function prologue
    push rbp
    mov rbp, rsp
    
    ; Function body: add_numbers(a: edi, b: esi) -> eax
    mov eax, edi        ; Move first parameter to return register
    add eax, esi        ; Add second parameter
    
    ; Function epilogue
    mov rsp, rbp
    pop rbp
    ret

main:
    ; Function prologue
    push rbp
    mov rbp, rsp
    
    ; Prepare arguments for add_numbers(5, 10)
    mov edi, 5          ; First argument
    mov esi, 10         ; Second argument
    call add_numbers    ; Call function
    
    ; Return value already in eax
    ; Function epilogue
    mov rsp, rbp
    pop rbp
    ret
```

**Step 2: Assemble and Test**
```bash
# Assemble
nasm -f elf64 simple_add.asm -o simple_add.o

# Link
ld simple_add.o -o simple_add

# Execute and check exit code
./simple_add
echo $?  # Should output 15 (5 + 10)
```

### Example 2: Memory Operations and Local Variables

**Input** (`memory_ops.jsav`):
```jsav
fn process_array() -> i32 {
    let mut arr: [i32; 3] = [1, 2, 3];
    let sum = arr[0] + arr[1] + arr[2];
    return sum;
}
```

**Step 1: Generate with Debug Information**
```bash
cargo run -- --input memory_ops.jsav --emit-asm --target x86_64-linux-gnu --debug-info --comments
```

**Expected Assembly with Comments**:
```nasm
section .text
    global process_array

process_array:
    ; Function prologue
    push rbp
    mov rbp, rsp
    sub rsp, 16         ; Allocate stack space for local array (aligned)
    
    ; Initialize array: arr = [1, 2, 3]
    mov dword [rbp-4], 1    ; arr[0] = 1
    mov dword [rbp-8], 2    ; arr[1] = 2
    mov dword [rbp-12], 3   ; arr[2] = 3
    
    ; Calculate sum: arr[0] + arr[1] + arr[2]
    mov eax, [rbp-4]        ; Load arr[0]
    add eax, [rbp-8]        ; Add arr[1]
    add eax, [rbp-12]       ; Add arr[2]
    
    ; Function epilogue
    mov rsp, rbp
    pop rbp
    ret
```

### Example 3: Cross-Platform ABI Demonstration

**Input** (`cross_platform.jsav`):
```jsav
fn multi_param(a: i32, b: i32, c: i32, d: i32, e: i32) -> i32 {
    return a + b + c + d + e;
}
```

**Generate for Different Platforms**:

```bash
# Linux (System V ABI)
cargo run -- --input cross_platform.jsav --emit-asm --target x86_64-linux-gnu -o linux.asm

# Windows (Microsoft x64 ABI)  
cargo run -- --input cross_platform.jsav --emit-asm --target x86_64-windows-msvc -o windows.asm

# macOS (System V ABI)
cargo run -- --input cross_platform.jsav --emit-asm --target x86_64-apple-darwin -o macos.asm
```

**Compare ABI Differences**:

**Linux/macOS Assembly (System V ABI)**:
```nasm
multi_param:
    push rbp
    mov rbp, rsp
    
    ; Parameters in: rdi, rsi, rdx, rcx, r8 (5th param on stack)
    mov eax, edi        ; a
    add eax, esi        ; + b
    add eax, edx        ; + c
    add eax, ecx        ; + d
    add eax, r8d        ; + e
    
    mov rsp, rbp
    pop rbp
    ret
```

**Windows Assembly (Microsoft x64 ABI)**:
```nasm
multi_param:
    push rbp
    mov rbp, rsp
    sub rsp, 32         ; Shadow space (32 bytes)
    
    ; Parameters in: rcx, rdx, r8, r9 (5th param on stack)
    mov eax, ecx        ; a
    add eax, edx        ; + b
    add eax, r8d        ; + c
    add eax, r9d        ; + d
    add eax, [rbp+48]   ; + e (from stack)
    
    add rsp, 32         ; Deallocate shadow space
    mov rsp, rbp
    pop rbp
    ret
```

## Validation and Testing

### Step 1: Semantic Equivalence Testing

```bash
# Run semantic equivalence validation
cargo run -- --input examples/test_functions.jsav --validate-semantics --test-cases 100

# Output shows:
# âœ… Function 'add_numbers': 100/100 test cases passed
# âœ… Function 'multiply': 100/100 test cases passed  
# âœ… Function 'factorial': 100/100 test cases passed
# âœ… Semantic equivalence: PASSED
```

### Step 2: Performance Benchmarking

```bash
# Benchmark generation performance
cargo run -- --input examples/large_module.jsav --benchmark --emit-asm

# Output shows:
# ðŸ“Š Performance Metrics:
#   - IR Instructions: 8,750
#   - Generation Time: 2.3 seconds
#   - Memory Usage: 45.2 MB (1.8x IR size)
#   - Instructions/sec: 3,804
# âœ… Performance targets: PASSED
```

### Step 3: Cross-Platform Assembly Validation

```bash
# Validate assembly syntax on all platforms
./scripts/validate_assembly.sh examples/

# Output:
# ðŸ”§ Linux x86_64: nasm assembly validation PASSED
# ðŸ”§ Windows x64: nasm assembly validation PASSED
# ðŸ”§ macOS x86_64: nasm assembly validation PASSED
# âœ… Cross-platform validation: PASSED
```

## Advanced Usage

### Custom Code Generation Options

```bash
# Generate with custom optimization and features
cargo run -- \
    --input advanced_example.jsav \
    --emit-asm \
    --target x86_64-linux-gnu \
    --optimization-level 2 \
    --enable-sse2 \
    --enable-avx \
    --max-stack-frame 2048 \
    --symbol-prefix "jsavrs_"
```

### Debug and Diagnostic Options

```bash
# Generate with comprehensive debugging information
cargo run -- \
    --input debug_example.jsav \
    --emit-asm \
    --debug-info \
    --comments \
    --verbose \
    --dump-ir \
    --show-register-allocation \
    --assembly-listing
```

### Integration with Build Systems

**Cargo Integration** (`Cargo.toml`):
```toml
[dependencies]
jsavrs = { path = ".", features = ["x86_64_codegen"] }

[[bin]]
name = "my_program"
path = "src/main.jsav"
```

**Build Script** (`build.rs`):
```rust
use jsavrs::x86_64::{AssemblyGenerator, TargetPlatform};

fn main() {
    let generator = AssemblyGenerator::new();
    let target = TargetPlatform::linux_x64();
    
    // Custom build logic
    generator.compile_to_assembly("src/main.jsav", &target)
        .expect("Assembly generation failed");
}
```

## Troubleshooting

### Common Issues and Solutions

**Issue**: `UnsupportedInstruction` error
```
Error: Unsupported IR instruction: vector_add at line 15, column 8
```
**Solution**: Check if the instruction requires SSE/AVX support and enable appropriate flags:
```bash
cargo run -- --input file.jsav --emit-asm --enable-sse2
```

**Issue**: `RegisterAllocationFailure` error
```
Error: Register allocation failed: too many live variables in function 'complex_calc'
```
**Solution**: Increase stack frame size or optimize variable usage:
```bash
cargo run -- --input file.jsav --emit-asm --max-stack-frame 4096
```

**Issue**: Cross-platform assembly differences
**Solution**: Use platform-specific validation and understand ABI differences documented in the examples above.

### Performance Optimization Tips

1. **Reduce IR Complexity**: Simplify complex expressions before IR generation
2. **Enable Optimizations**: Use `--optimization-level 2` for production builds
3. **Monitor Memory Usage**: Use `--benchmark` to track memory overhead
4. **Use Appropriate Instruction Sets**: Enable SSE/AVX for floating-point heavy code

## Success Criteria Validation

This quickstart demonstrates all functional requirements:

âœ… **FR-001**: IR to NASM assembly translation  
âœ… **FR-002**: Semantic preservation (validated through testing)  
âœ… **FR-003**: Cross-platform ABI support (Windows x64, System V)  
âœ… **FR-004**: Function prologues and epilogues generation  
âœ… **FR-005**: Register preservation according to ABI  
âœ… **FR-006**: Stack alignment compliance  
âœ… **FR-007**: Standard linker compatibility  
âœ… **FR-008**: Proper section layout and relocation  
âœ… **FR-009**: Semantic equivalence validation  
âœ… **FR-010**: Cross-platform compatibility  
âœ… **FR-011**: NASM assembleable output  
âœ… **PR-001**: Performance targets (< 5 seconds for 10K instructions)  
âœ… **QR-001**: Automated verification testing  

## Next Steps

1. **Integration**: Integrate the assembly generator into your jsavrs compiler pipeline
2. **Testing**: Run comprehensive test suites on your specific use cases
3. **Optimization**: Profile and optimize for your specific workload patterns
4. **Extension**: Add support for additional instruction sets or calling conventions as needed

For detailed implementation information, see `data-model.md` and `contracts/assembly_generator_api.md`.