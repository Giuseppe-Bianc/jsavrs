# Implementation Plan: Multi-pass IR Optimizer

**Branch**: `012-multi-pass-ir-optimizer` | **Date**: 2025-11-01 | **Spec**: [spec.md](./spec.md)  
**Input**: Feature specification from `/specs/012-multi-pass-ir-optimizer/spec.md`

## Summary

The multi-pass IR optimizer transforms SSA-form Modules through systematic analysis and optimization passes while guaranteeing semantic preservation. It implements a layered architecture with three core subsystems: an analysis framework computing dataflow information (reaching definitions, live variables, use-def chains, alias analysis, loop detection, constant propagation), transformation passes organized in phases (early: SCCP, ADCE, copy propagation; middle: GVN/CSE, LICM, IV optimization, loop unrolling; late: instruction combining, algebraic simplification, strength reduction, phi optimization; memory: store-to-load forwarding, redundant load elimination, dead store elimination), and verification infrastructure ensuring SSA/CFG/type consistency with automatic rollback on failures. The optimizer leverages existing jsavrs IR infrastructure (Module, Function, BasicBlock, Instruction, Value, ControlFlowGraph via petgraph DiGraph, DominanceInfo, SsaTransformer) with zero external dependencies beyond petgraph, operating at configurable optimization levels (O0: disabled, O1: basic single-iteration passes, O2: full multi-iteration with Andersen alias analysis, O3: aggressive with increased thresholds) and producing detailed performance metrics.

## Technical Context

**Language/Version**: Rust 1.75+ (stable, using existing jsavrs toolchain)  
**Primary Dependencies**: petgraph (already in use for CFG representation), bit-vec (for dense boolean sets in dataflow analysis)  
**Storage**: In-memory IR structures (Module, Function, BasicBlock, Instruction, Value) with no persistent storage  
**Testing**: cargo test (unit tests), insta (snapshot tests for IR transformations), criterion (benchmarks for optimization performance)  
**Target Platform**: Cross-platform (Windows, macOS, Linux) compiler infrastructure  
**Project Type**: Single project (compiler optimization module within existing jsavrs codebase)  
**Performance Goals**: >=5% median instruction reduction at O2, <30% compile-time overhead at O1, <100% overhead at O2  
**Constraints**: Zero semantic changes (test suite must pass identically), SSA/CFG invariants must be preserved, function-level rollback on verification failure  
**Scale/Scope**: Handles functions with 100s-1000s of instructions, 10s-100s of basic blocks, max 10 pass iterations at O2/O3

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Evaluation**:

✅ **Safety First**: Optimizer maintains memory safety through Rust ownership, uses Result<T, OptimizerError> for error handling, minimal unsafe (only petgraph graph indexing), verification prevents invalid IR states.

✅ **Performance Excellence**: Designed for compilation speed with efficient data structures (Vec for instruction sequences, HashMap with FxHasher, BitVec for dataflow, petgraph DiGraph reused from CFG), configurable iteration limits, early-exit on fixed point.

✅ **Cross-Platform Compatibility**: Pure Rust implementation with no platform-specific dependencies, leverages existing jsavrs cross-platform infrastructure.

✅ **Modular Extensibility**: Plugin architecture via OptimizationPass trait, clear separation of analysis/transformation/verification layers, new passes register with PassManager declaring analysis dependencies.

✅ **Test-Driven Reliability**: Comprehensive testing strategy (unit tests for individual passes, integration tests comparing program outputs, property tests for SSA/CFG invariant preservation, benchmarks for performance validation).

✅ **Snapshot Validation**: Uses insta for IR transformation snapshot tests, verifies instruction sequences, CFG structure, and debug information preservation.

✅ **Documentation Rigor**: Detailed rustdoc comments for all public APIs with Examples sections, comprehensive research.md and data-model.md, architectural decision documentation in quickstart.md.

**Result**: PASS - All constitution principles are satisfied without violations.

## Project Structure

### Documentation (this feature)

```text
specs/012-multi-pass-ir-optimizer/
├── plan.md              # This file (implementation strategy and architecture)
├── research.md          # Phase 0 output (optimization algorithms, dataflow analysis, alias analysis)
├── data-model.md        # Phase 1 output (IR structures, analysis results, pass interfaces)
├── quickstart.md        # Phase 1 output (integration guide, usage examples, configuration)
├── contracts/           # Phase 1 output (OptimizationPass trait, Analysis trait, verification interfaces)
│   ├── optimization_pass.md
│   ├── analysis_trait.md
│   └── verification.md
└── tasks.md             # Phase 2 output (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
src/
├── ir/
│   ├── optimizer/
│   │   ├── mod.rs                    # Main entry point: optimize_module()
│   │   ├── config.rs                 # OptimizerConfig, OptLevel enum
│   │   ├── error.rs                  # OptimizerError enum
│   │   ├── metrics.rs                # PassMetrics, OptimizerReport
│   │   ├── analysis/
│   │   │   ├── mod.rs                # Analysis trait, AnalysisKind enum
│   │   │   ├── use_def.rs            # UseDefManager: use-def and def-use chains
│   │   │   ├── reaching_defs.rs      # ReachingDefinitions: worklist dataflow
│   │   │   ├── live_vars.rs          # LiveVariables: backward dataflow
│   │   │   ├── constants.rs          # ConstantLattice: SCCP lattice
│   │   │   ├── alias.rs              # AliasAnalysis trait, AndersenAnalysis, ConservativeAnalysis
│   │   │   ├── loops.rs              # LoopInfo: natural loop detection
│   │   │   └── gvn.rs                # GlobalValueNumbering: expression hashing
│   │   ├── passes/
│   │   │   ├── mod.rs                # OptimizationPass trait, PassResult
│   │   │   ├── sccp.rs               # Sparse conditional constant propagation
│   │   │   ├── adce.rs               # Aggressive dead code elimination
│   │   │   ├── copy_prop.rs          # Copy propagation
│   │   │   ├── gvn_cse.rs            # Global value numbering / CSE
│   │   │   ├── licm.rs               # Loop-invariant code motion
│   │   │   ├── iv_opt.rs             # Induction variable optimization
│   │   │   ├── loop_unroll.rs        # Loop unrolling
│   │   │   ├── inst_combine.rs       # Instruction combining
│   │   │   ├── algebraic_simp.rs     # Algebraic simplification
│   │   │   ├── strength_reduction.rs # Strength reduction
│   │   │   ├── phi_opt.rs            # Phi node optimization
│   │   │   ├── type_cast_opt.rs      # Type/cast optimization
│   │   │   ├── store_to_load_fwd.rs  # Store-to-load forwarding
│   │   │   ├── redundant_loads.rs    # Redundant load elimination
│   │   │   └── dead_stores.rs        # Dead store elimination
│   │   ├── verification/
│   │   │   ├── mod.rs                # VerificationError enum
│   │   │   ├── ssa_verify.rs         # verify_ssa_form()
│   │   │   ├── cfg_verify.rs         # verify_cfg_consistency()
│   │   │   ├── type_verify.rs        # verify_type_consistency()
│   │   │   └── rollback.rs           # FunctionSnapshot capture/restore
│   │   └── pass_manager.rs           # PassManager, AnalysisManager
│   ├── module.rs                     # Existing Module IR structure
│   ├── function.rs                   # Existing Function IR structure
│   ├── basic_block.rs                # Existing BasicBlock IR structure
│   ├── instruction.rs                # Existing Instruction IR structure
│   ├── value.rs                      # Existing Value IR structure
│   ├── cfg.rs                        # Existing ControlFlowGraph (petgraph DiGraph)
│   ├── dominance.rs                  # Existing DominanceInfo
│   └── ssa.rs                        # Existing SsaTransformer
├── main.rs                           # Main compiler driver (integration point)
└── cli.rs                            # CLI argument parsing (--opt-level flag)

tests/

├── sccp_tests.rs                 # Unit tests for SCCP
├── adce_tests.rs                 # Unit tests for ADCE
├── gvn_cse_tests.rs              # Unit tests for GVN/CSE
├── licm_tests.rs                 # Unit tests for LICM
├── iv_opt_tests.rs               # Unit tests for IV optimization
├── loop_unroll_tests.rs          # Unit tests for loop unrolling
├── verification_tests.rs         # Unit tests for verification
├── integration_tests.rs          # End-to-end optimization tests
├── property_tests.rs             # Proptest-based invariant checks
└── snapshots/                        # Insta snapshot files for IR transformations

benches/
└── optimizer_bench.rs                # Criterion benchmarks for optimizer
```

**Structure Decision**: Single project structure (Option 1) is selected because the optimizer is a core compiler component integrated directly into the existing jsavrs codebase. It extends the existing `src/ir/` module with a new `optimizer/` subdirectory, maintaining consistency with the existing module organization (lexer, parser, semantic, ir, asm). This structure supports the modular extensibility principle by keeping optimization as a well-defined layer with clear interfaces to existing IR infrastructure.

## Complexity Tracking

*No violations detected - section not required.*
